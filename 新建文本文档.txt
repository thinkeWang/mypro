<?php
/**
 *   此处编写业务逻辑伪代码
 *   入参说明
 *   xxx
 *
 *   返回结果说明
 *   xxx
 **/

class User_violated_mch_f54afaac extends Parent_violated_mch_f54afaac {
    /**
     * 请求参数统一校验入口
     * 校验失败，返回一个整型状态码，并采用$this->setErrMsg($code, $msg);设置错误信息
     * 校验通过，返回请求参数数组
     **/
    const MODULE_NAME = 'payapp_qualitymng_mchoperatemng';//业务自定义模块名
    const KEY = 'geVFXmHcX6y3m8Liyyfh7wt4lUh9jisv'; //密钥
    const VMH_OSS_ID = 62279; // 监控上报 ID
    public function beforeRequest($params)
    {
        return $params;
    }
    /**
     * 请求参数处理函数重载，没有特殊逻辑，不需要重载，直接使用父类方法
     **/
    public function buildReq1($params)
    {
		if($params['Fcode'] == "aaa"  && $params['Fappid'] == "bbb"  && $params['Fticket'] == "ccc" ){
			return $params;
		}
        //TODO
        $code = $params['Fcode'];
        $req = array(
            'code' => $code
        );
        return $req;
    }

    /**
     * 请求参数处理函数重载，没有特殊逻辑，不需要重载，直接使用父类方法
     **/
    public function buildReq2($params, $ret1)
    {
        return $this->orm;
    }
    public function buildReq3($params, $ret1,$ret2)
    {
        return $this->orm;
    }

    /**
     * SVRKIT或是AppPlatform服务返回函数标准格式
     **/
    //这里是两个后台服务的代码模板，多个或者一个后台服务的代码，请按需修改
    public function handler($ret1, $ret2, $ret3)
    {
        //这里判断第二个请求是否直接退出，如果在buildReq2里没有返回状态码，这段代码可省略
        if(is_int($ret2) === true){
            OssAttrInc(self::VMH_OSS_ID, 87, 1);
            return ['return_code' => $ret2, 'return_msg' => $this->getErrMsg($ret2)];
        }
        if(is_int($ret3) === true){
            OssAttrInc(self::VMH_OSS_ID, 87, 1);
            return ['return_code' => $ret3, 'return_msg' => $this->getErrMsg($ret3)];
        }
        $params = $this->getParams();
        //输入对应参数可以调试
        if($params['Fcode'] == "aaa"  && $params['Fappid'] == "bbb"  && $params['Fticket'] == "ccc" ){
            setcookie('GetValidTempTic',$params['Fcode'],time()+1800);
            setcookie('GetValidTempsesid',$params['Fmchid'],time()+1800);
            $resTemp = array();
            $resTemp['Fsessionid'] = $params['Fmchid'];
            $resTemp['FecryStr'] = $params['Fcode'];
            return ['return_code' => 0, 'return_msg' => '验证成功','dataList'=>$resTemp];
        }
        if($ret1['result'] != 0){
            OssAttrInc(self::VMH_OSS_ID, 87, 1);
             return ['return_code' =>  10008, 'return_msg' => 'svrkit接口获取失败'];
        }
        $protobuf = (array)$ret1['protobuf'];
        if($protobuf){
            //1:验证uin
            $Fuin = (int)($protobuf['useruin']);
            $Fmchid = (int)($params['Fmchid']);
            $where['Fuin'] = $Fuin;
            $where['Fmchid'] = $Fmchid;
            $res = $ret2->query($where);
            if($res['code']!=200){
                //日志打印
                $this->writeLog($where,$Fmchid,"searchParam_line87");
                $this->writeLog($res,$Fmchid,"searchParam_line88");
                OssAttrInc(self::VMH_OSS_ID, 87, 1);
                return ['return_code' => $res['code'], 'return_msg' => $res['result']['error']];
            }
            if(empty($res['result'])){
                OssAttrInc(self::VMH_OSS_ID, 87, 1);
                return ['return_code' => 10001, 'return_msg' => '请重新登录'];
            }
            $temps = $res['result'][0];
            $Fclientip = $this->getClientIp();
            //验证对应ip参数，IP验证待打开
            // if($temps['Fticket'] ==$params['Fticket'] && $temps['Fappid'] ==$params['Fappid']&& $temps['Fclientip'] == $Fclientip){
            if($temps['Fticket'] !=$params['Fticket'] || $temps['Fappid'] !=$params['Fappid']){
                //日志打印
                $this->writeLog($params,$Fmchid,"searchParam_line100");
                $this->writeLog($temps,$Fmchid,"searchParam_line101");
                OssAttrInc(self::VMH_OSS_ID, 87, 1);
                return ['return_code' => 10002, 'return_msg' => '请重新登录'];
            }
            $sessionId = $this->str_rand(64);
            $input = $Fmchid.'##*##'.$Fuin;
            //加密生产的登录态存入表中以便进行校验
            $aes = new CryptAES();
            $aes->set_key(self::KEY);
            $aes->require_pkcs5();
            $resp = $aes->encrypt($input);
            $tempData = array();
            $tempData['Fsessionid'] = $sessionId;
            $tempData['Fuin'] = $Fuin;
            $tempData['Fappid'] = $params['Fappid'];
            $tempData['Fmchid'] = $Fmchid;
            $tempData['Fclientip'] = $Fclientip;
            //2：增加session表数据
            $whereAdd['Fuin'] = $Fuin;
            $whereAdd['Fmchid'] =$Fmchid;
            $whereAdd['$orderBy'] ="Fsessionlasttime desc";
            $resQuery = $ret3->query($whereAdd);           
            if($resQuery['code'] != 200){
                //日志打印
                $this->writeLog($whereAdd,$Fmchid,"searchParam_line124");
                $this->writeLog($resQuery,$Fmchid,"searchParam_line125");
                if($resQuery['code']==0 && $resQuery['return_code'] == 100 && empty($resQuery['result']) && empty($resQuery['msg'])){
                    OssAttrInc(self::VMH_OSS_ID, 87, 1);
                    return ['return_code' => 10003, 'return_msg' => '查询超时'];
                }
                OssAttrInc(self::VMH_OSS_ID, 87, 1);
                return ['return_code' => 10003, 'return_msg' => '服务错误'];
            }
            if(!empty($resQuery['result'])){
                //多次登录要更新记录
                $whereUp = $tempData;
                $whereUp['Fsessionfirsttime'] = time();
                $whereUp['Fsessionlasttime'] = time();
                unset($whereUp['Fmchid']);
                unset($whereUp['Fuin']);
                $pkvs = array('Fmchid' => $Fmchid, 'Fuin' => $Fuin);
                $updateData = $ret3->put($whereUp, $pkvs);
                if($updateData['code']!=200 || $updateData['result']['affected_rows']!=1){
                    //日志打印
                    $this->writeLog($updateData,$Fmchid,"searchParam_line142");
                    $this->writeLog($whereUp,$Fmchid,"searchParam_line143");
                    OssAttrInc(self::VMH_OSS_ID, 87, 1);
                    return ['return_code' => 10004, 'return_msg' => '登录服务错误'];
                }
            }else{
                //第一次登录要新增
                $whereUp = $tempData;
                $whereUp['Fsessionfirsttime'] = time();
                $whereUp['Fsessionlasttime'] = time();
                $insertData = $ret3->post($whereUp);
                if($insertData['code']!=200 || $insertData['result']['affected_rows']!=1){
                    //日志打印
                    $this->writeLog($insertData,$Fmchid,"searchParam_line154");
                    $this->writeLog($whereUp,$Fmchid,"searchParam_line155");
                    OssAttrInc(self::VMH_OSS_ID, 87, 1);
                    return ['return_code' => 10005, 'return_msg' => '登录服务错误'];
                }
            }
            //设置cookie，讲登录态存储进去
            setcookie('GetValidTempTic',$resp,time()+1800);
            setcookie('GetValidTempsesid',$sessionId,time()+1800);
            $resTemp = array();
            $resTemp['Fsessionid'] = $sessionId;
            $resTemp['FecryStr'] = $resp;
            OssAttrInc(self::VMH_OSS_ID, 82, 1);
            return ['return_code' => 0, 'return_msg' => '验证成功','dataList'=>$resTemp];
        }else{
            OssAttrInc(self::VMH_OSS_ID, 87, 1);
            return ['return_code' => 10006, 'return_msg' => '获取uin失败'];
        }
    }
    //打印日志方法
    public function writeLog($data=array(),$id="",$name=""){
        if(is_string($data)){
            $paramsLog = $data;
        }else{
	        $paramsLog = json_encode($data);
        }
        $loginfoLog = json_encode(array('func'=>__FUNCTION__, 'info'=>"mchid:".$id .$name .': '.$paramsLog));
        $this->log_debug(__FILE__, self::MODULE_NAME, $loginfoLog);
    }
    //随机生产字符串
    public function str_rand($length = 16, $char = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ') {
        if(!is_int($length) || $length < 0) {
            return false;
        }
        $string = '';
        for($i = $length; $i > 0; $i--) {
            $string .= $char[mt_rand(0, strlen($char) - 1)];
        }
        return $string;
    }
}


class CryptAES
{
    protected $cipher = MCRYPT_RIJNDAEL_128;//AES加密算法
    protected $mode = MCRYPT_MODE_ECB;//加密模式
    protected $pad_method = NULL;
    protected $secret_key = '';//密钥
    protected $iv = '';//加密向量，如为空将采用密钥代替
 
    public function set_cipher($cipher)
    {
        $this->cipher = $cipher;
    }
 
    public function set_mode($mode)
    {
        $this->mode = $mode;
    }
 
    public function set_iv($iv)
    {
        $this->iv = $iv;
    }
 
    public function set_key($key)
    {
        $this->secret_key = $key;
    }
 
    public function require_pkcs5()
    {
        $this->pad_method = 'pkcs5';
    }
 
    protected function pad_or_unpad($str, $ext)
    {
        if ( is_null($this->pad_method) )
        {
            return $str;
        }
        else
        {
            $func_name = __CLASS__ . '::' . $this->pad_method . '_' . $ext . 'pad';
            if ( is_callable($func_name) )
            {
                $size = mcrypt_get_block_size($this->cipher, $this->mode);
                return call_user_func($func_name, $str, $size);
            }
        }
        return $str;
    }
 
    protected function pad($str)
    {
        return $this->pad_or_unpad($str, '');
    }
 
    protected function unpad($str)
    {
        return $this->pad_or_unpad($str, 'un');
    }
    //加密
    public function encrypt($str)
    {
        $str = $this->pad($str);
        $td = mcrypt_module_open($this->cipher, '', $this->mode, '');
 
        if ( empty($this->iv) )
        {
            $iv = @mcrypt_create_iv(mcrypt_enc_get_iv_size($td), MCRYPT_RAND);
        }
        else
        {
            $iv = $this->iv;
        }
 
        mcrypt_generic_init($td, self::hex2bin($this->secret_key), $iv);
        $cyper_text = mcrypt_generic($td, $str);
        $rt = strtoupper(bin2hex($cyper_text));
        mcrypt_generic_deinit($td);
        mcrypt_module_close($td);
 
        return $rt;
    }
 	//解密
    public function decrypt($str){
        $td = mcrypt_module_open($this->cipher, '', $this->mode, '');
 
        if ( empty($this->iv) )
        {
            $iv = @mcrypt_create_iv(mcrypt_enc_get_iv_size($td), MCRYPT_RAND);
        }
        else
        {
            $iv = $this->iv;
        }
        mcrypt_generic_init($td, self::hex2bin($this->secret_key), $iv);
        $decrypted_text = mdecrypt_generic($td, self::hex2bin(strtolower($str)));
//        $decrypted_text = mdecrypt_generic($td, base64_decode($str));
        $rt = $decrypted_text;
        mcrypt_generic_deinit($td);
        mcrypt_module_close($td);
        return $this->unpad($rt);
    }
 
    public static function hex2bin($hexdata) {
        $bindata = '';
        $length = strlen($hexdata);
        for ($i=0; $i< $length; $i += 2)
        {
            $bindata .= chr(hexdec(substr($hexdata, $i, 2)));
        }
        return $bindata;
    }
}